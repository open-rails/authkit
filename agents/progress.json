{
  "issues": [
    {
      "name": "Move ephemeral auth state to Redis (codes, SIWS challenges, rate limits)",
      "description": "Use Redis-compatible storage (Garnet) for ephemeral auth state (verification codes, reset tokens, SIWS challenges, and other short-lived entries) so we don't rely on Postgres TTL cleanup. This also makes SIWS safe in multi-instance deployments. In-memory caches remain as a fallback when Garnet is not configured, but they are not safe for distributed use. AuthKit should accept a Redis client interface from the host app (Garnet implements the same protocol).",
      "tasks": [
        "[x] Define a minimal Redis client interface (Get/Set/Del) and accept it via AuthKit options",
        "[x] Add Garnet/Redis config in host apps; pass client into AuthKit (no internal dialer)",
        "[x] Define key prefixes + TTLs for: email/phone verify codes, password resets, pending registrations, 2FA codes, SIWS challenges, rate limit buckets",
        "[x] Replace Postgres writes for ephemeral tables with Redis writes (keep Postgres for durable user/session records)",
        "[x] Update verification flows to read from Redis and delete on success",
        "[x] Add store selection: memory|redis|postgres (configurable). Memory is dev-only; redis required for multi-instance prod; postgres is explicit opt-in adapter",
        "[x] Enforce: in prod + multi-instance, require redis; otherwise fail fast with clear error",
        "[x] Keep in-memory cache fallback for dev/single-instance",
        "[x] Update migrations/docs: remove ephemeral tables or leave for backward compat; document required Redis for HA",
        "[x] Add tests for Redis-backed flows (skip when Redis not configured)"
      ],
      "completed": true
    },
    {
      "name": "Unify OAuth/OIDC routes under /auth/oauth/:provider",
      "description": "Expose a single route pattern for all external identity providers (OIDC and OAuth) under /auth/oauth/:provider to simplify client integration while keeping provider-specific logic internally.",
      "tasks": [
        "[ ] Add new routes: GET /auth/oauth/:provider/login, GET /auth/oauth/:provider/callback, POST /auth/oauth/:provider/link/start",
        "[ ] Wire OIDC providers (google/apple/etc) to the new /auth/oauth/:provider routes without changing internal validation flow",
        "[ ] Wire Discord OAuth to the same /auth/oauth/:provider routes",
        "[ ] Decide whether to keep /auth/oidc/* and /auth/oauth/discord/* as aliases or deprecate with docs",
        "[ ] Update docs (api-endpoints.md) with new unified route pattern and provider list"
      ],
      "completed": false
    },
    {
      "name": "Add phone number change flow (request/confirm/resend)",
      "description": "Add a phone change flow for existing users mirroring the email change behavior. This should verify the new phone number via SMS code and update the user's phone only after confirmation.",
      "tasks": [
        "[ ] Add core service methods: RequestPhoneChange(userID, newPhone), ConfirmPhoneChange(userID, code), ResendPhoneChangeCode(userID)",
        "[ ] Add persistence for pending phone change verification (reuse phone_verifications with a new purpose or add a dedicated table)",
        "[ ] Add Gin handlers: POST /auth/user/phone/change/request, POST /auth/user/phone/change/confirm, POST /auth/user/phone/change/resend",
        "[ ] Add rate limit keys for request/confirm/resend",
        "[ ] Update docs (api-endpoints.md) with phone change routes and expected errors"
      ],
      "completed": false
    },
    {
      "name": "Add phone verification request endpoint",
      "description": "Add POST /auth/phone/verify/request endpoint for existing users to add/verify a phone number, mirroring the existing POST /auth/email/verify/request flow.",
      "tasks": [
        "[DONE] Add RequestPhoneVerificationByPhone() method to core/service.go",
        "[DONE] Create phone_verify_request_post.go handler",
        "[DONE] Add rate limit constant RLPhoneVerifyRequest to ginutil",
        "[DONE] Wire up route in service.go GinRegisterAPI",
        "[DONE] Update api-endpoints.md documentation"
      ],
      "completed": true
    },
    {
      "name": "Enhance UserContext with convenience methods",
      "description": "Both doujins and hentai0 wrap authkit's UserContext with their own logic to check roles/entitlements. This should be built into authkit's UserContext directly.\n\n## Problem\n\ndoujins has `internal/auth/user_context.go` with:\n```go\ntype UserContext struct {\n    User         *views.User  // Project-specific\n    IsAdmin      bool\n    IsLoggedIn   bool\n    Language     string\n    Roles        []string\n    Entitlements []string\n}\n```\n\nAnd `internal/middleware/user_context.go` computes these flags:\n```go\nuserCtx.IsAdmin = containsIgnoreCase(userCtx.Roles, \"admin\")\n```\n\nhentai0 uses authkit's UserContext directly but lacks these convenience methods.\n\n## Solution\n\nAdd convenience methods to authkit's `UserContext` in `adapters/gin/userctx.go`:\n\n```go\n// Already exists:\nfunc (uc UserContext) IsAdmin() bool { return hasString(uc.Roles, \"admin\") }\n\n// Add these:\nfunc (uc UserContext) IsLoggedIn() bool { return uc.UserID != \"\" }\nfunc (uc UserContext) HasRole(role string) bool { return hasString(uc.Roles, role) }\nfunc (uc UserContext) HasEntitlement(ent string) bool { return hasString(uc.Entitlements, ent) }\n```\n\n## Important: NO IsPremium() method\n\nDo NOT add `IsPremium()` method. This is overly specific and doesn't scale. Instead, callers should use the generic `HasEntitlement(\"premium\")`. Same logic applies to any future entitlement types - use the generic method, not dedicated boolean methods.\n\n## Migration\n\nAfter authkit changes:\n- doujins can simplify `internal/middleware/user_context.go` to just use `authgin.UserContext` methods\n- doujins can potentially remove `internal/auth/user_context.go` if the only additions were computed flags\n- hentai0 gains these methods automatically\n\n## Note\n\nLanguage middleware and response envelopes are NOT part of this issue - those belong in a separate shared library (e.g., `go-api-common`), not authkit.",
      "tasks": [
        "[x] Add IsLoggedIn() method to UserContext (check UserID != \"\")",
        "[x] Add HasRole(role string) method to UserContext",
        "[x] Add HasEntitlement(ent string) method to UserContext",
        "[x] Add unit tests for new UserContext methods",
        "[x] Downstream app wrapper removal tracked in app repos"
      ],
      "completed": true
    },
    {
      "name": "Remove is_active (use ban/delete only)",
      "description": "Replace the `profiles.users.is_active` boolean with explicit ban/delete semantics.\n\n## Requirements\n\n- Only two access-blocking states exist:\n  - banned (reversible): `banned_at IS NOT NULL`\n  - deleted (soft delete): `deleted_at IS NOT NULL`\n- Admin delete and user self-delete both set `deleted_at` (soft delete) initially.\n- Login/token issuance must refuse banned/deleted users.\n- Deleted users remain soft-deleted for 30 days, then are hard-deleted.\n\n## Target semantics\n\n- Active user is implied: `deleted_at IS NULL AND banned_at IS NULL`.\n- Ban should revoke sessions immediately.\n- Soft delete should revoke sessions immediately.\n- Hard delete occurs after 30 days (purge job).",
      "tasks": [
        "SCHEMA/MIGRATIONS:",
        "[x] Add `profiles.users.banned_at timestamptz` (optional: banned_reason, banned_by)",
        "[x] Backfill `banned_at` for existing users with is_active=false and deleted_at IS NULL (treat as banned)",
        "[x] Remove `profiles.users.is_active` (drop column) after code is migrated",
        "",
        "CORE LOGIC:",
        "[x] Replace all `IsActive` checks with `deleted_at IS NULL AND banned_at IS NULL`",
        "[x] Replace `SetActive` APIs with explicit `BanUser` / `UnbanUser` + `SoftDeleteUser` (deleted_at)",
        "[x] Ensure ban and soft delete revoke refresh sessions (issuer-scoped) consistently",
        "[x] Ensure JWT issuance paths refuse banned/deleted users (password login, OAuth/OIDC callbacks, SIWS, refresh, etc.)",
        "[x] Ensure authz gates respect banned/deleted (Required middleware, RequireAdmin/RequireRole/RequireEntitlement, and any DB-backed UserContext enrichment should deny when banned_at or deleted_at is set)",
        "[x] Ensure admin/live DB checks donâ€™t treat \"row exists\" as sufficient; they must join/filter on `profiles.users` status",
        "",
        "HTTP API:",
        "[x] Change admin ban/unban endpoints to set/clear `banned_at` (and revoke sessions on ban)",
        "[x] Remove or repurpose \"toggle active\" endpoint (make it ban/unban; no generic active toggle)",
        "[x] Change `DELETE /auth/user` to call soft delete (`deleted_at=now()` + revoke sessions)",
        "[x] Change admin delete endpoint to soft delete by default (`deleted_at=now()`), not hard delete",
        "",
        "ADMIN VIEWS:",
        "[x] Update AdminUser / listing to expose `banned_at` and `deleted_at` (and derived booleans if needed)",
        "[x] Update any filters/search that currently use is_active",
        "",
        "RETENTION + PURGE (30 DAYS):",
        "[x] Add `profiles.users.deleted_at` retention policy: hard-delete after 30 days from deleted_at",
        "[x] Provide an AuthKit River module so host apps can \"plug in\" purge without re-implementing logic:",
        "      - A River job args type (`authkit/riverjobs.PurgeDeletedUsersArgs`) with params: retention_days, batch_size",
        "      - A worker implementation that selects `deleted_at < now() - retention_days` and hard-deletes authkit-owned rows",
        "      - Helpers: `RegisterPurgeDeletedUsersWorker` and `AddPurgeDeletedUsersPeriodicJob`",
        "[x] Define a host callback for app-domain cleanup/anonymization, invoked before the authkit hard-delete:",
        "      - `BeforeUserHardDelete(ctx, user_id) error` (delete likes/favorites, anonymize comments, etc.)",
        "[ ] Document and enforce downstream data policy in host apps (examples):",
        "      - comments: keep content by changing FK to `ON DELETE SET NULL` (so author becomes NULL on hard-delete); frontend renders author=NULL as \"user deleted\" (also handle legacy anonymous comments via anon_name when present)",
        "      - reactions/favorites: usually delete (cascade or explicit cleanup)",
        "      - posts/content with non-null author_id: decide per-app (either cascade-delete posts on user hard-delete, or switch author FK to SET NULL and render \"user deleted\")",
        "      - ClickHouse analytics/events: treat as append-only history; user_id may remain in event rows after user purge (acceptable; avoid expensive deletes)",
        "      - billing/audit/security logs: retain required records; remove/obfuscate PII as needed",
        "",
        "TESTS/VALIDATION:",
        "[ ] Add tests: banned users cannot log in; deleted users cannot log in; unban restores access; ban revokes sessions; delete revokes sessions",
        "[ ] Add tests for purge candidate selection: deleted_at older/newer than cutoff",
        "[ ] Run migration path test: old data -> backfill -> code works -> drop is_active"
      ],
      "completed": false
    }
  ],
  "completed_features": [
    {
      "name": "Sign In With Solana (SIWS)",
      "completed_at": "2025-12-04",
      "summary": "Implemented SIWS authentication with challenge/login/link endpoints, Ed25519 signature verification, and nonce-based replay protection."
    }
  ]
}
