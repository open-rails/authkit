{
  "issues": [
    {
      "name": "Admin undelete user (restore soft-deleted users)",
      "id_number": 1,
      "description": "AuthKit supports soft-deleting users via `deleted_at` (self-delete: `DELETE /auth/user`; admin delete: `DELETE /auth/admin/users/:user_id`) and then hard-deleting later via the purge worker. Add an admin-only restore endpoint so admins can restore a user before they are hard-deleted.\n\nSemantics:\n- Restore only clears `profiles.users.deleted_at` (and updates `updated_at`).\n- Do not change ban state (banned users remain banned after restore).\n- Do not recreate sessions; deleted users had sessions revoked, so they must log in again.\n- Idempotent: restoring an already-restored user is a no-op.\n\nEndpoint:\n- `POST /auth/admin/users/:user_id/restore` (ADMIN)\n- `GET /auth/admin/users/deleted` (ADMIN) for listing deleted users.",
      "tasks": [
        "[x] Core: Add restore method that clears deleted_at (no ban changes) and returns not-found when user is missing",
        "[x] HTTP (gin): Add admin restore route and deleted-users list route under `/auth/admin`",
        "[x] HTTP (gin): Ensure endpoint requires admin via existing RequireAdmin middleware",
        "[x] Tests: Add minimal handler tests for restore (ok + not_found)",
        "[x] Docs: Update `agents/api-endpoints.md` to include restore + deleted list"
      ],
      "completed": true
    },
    {
      "name": "Move ephemeral auth state to Redis (codes, SIWS challenges, rate limits)",
      "id_number": 2,
      "description": "Use Redis-compatible storage (Garnet) for ephemeral auth state (verification codes, reset tokens, SIWS challenges, and other short-lived entries) so we don't rely on Postgres TTL cleanup. This also makes SIWS safe in multi-instance deployments. In-memory caches remain as a fallback when Garnet is not configured, but they are not safe for distributed use. AuthKit should accept a Redis client interface from the host app (Garnet implements the same protocol).",
      "tasks": [
        "[x] Define a minimal Redis client interface (Get/Set/Del) and accept it via AuthKit options",
        "[x] Add Garnet/Redis config in host apps; pass client into AuthKit (no internal dialer)",
        "[x] Define key prefixes + TTLs for: email/phone verify codes, password resets, pending registrations, 2FA codes, SIWS challenges, rate limit buckets",
        "[x] Replace Postgres writes for ephemeral tables with Redis writes (keep Postgres for durable user/session records)",
        "[x] Update verification flows to read from Redis and delete on success",
        "[x] Add store selection: memory|redis|postgres (configurable). Memory is dev-only; redis required for multi-instance prod; postgres is explicit opt-in adapter",
        "[x] Enforce: in prod + multi-instance, require redis; otherwise fail fast with clear error",
        "[x] Keep in-memory cache fallback for dev/single-instance",
        "[x] Update migrations/docs: remove ephemeral tables or leave for backward compat; document required Redis for HA",
        "[x] Add tests for Redis-backed flows (skip when Redis not configured)"
      ],
      "completed": true
    },
    {
      "name": "Unify OAuth/OIDC routes under /auth/oauth/:provider",
      "id_number": 3,
      "description": "Expose a single route pattern for all external identity providers (OIDC and OAuth) under /auth/oauth/:provider to simplify client integration while keeping provider-specific logic internally.",
      "tasks": [
        "[ ] Add new routes: GET /auth/oauth/:provider/login, GET /auth/oauth/:provider/callback, POST /auth/oauth/:provider/link/start",
        "[ ] Wire OIDC providers (google/apple/etc) to the new /auth/oauth/:provider routes without changing internal validation flow",
        "[ ] Wire Discord OAuth to the same /auth/oauth/:provider routes",
        "[ ] Decide whether to keep /auth/oidc/* and /auth/oauth/discord/* as aliases or deprecate with docs",
        "[ ] Update docs (api-endpoints.md) with new unified route pattern and provider list"
      ],
      "completed": false
    },
    {
      "name": "Add phone number change flow (request/confirm/resend)",
      "id_number": 4,
      "description": "Add a phone change flow for existing users mirroring the email change behavior. This should verify the new phone number via SMS code and update the user's phone only after confirmation.",
      "tasks": [
        "[ ] Add core service methods: RequestPhoneChange(userID, newPhone), ConfirmPhoneChange(userID, code), ResendPhoneChangeCode(userID)",
        "[ ] Add persistence for pending phone change verification (reuse phone_verifications with a new purpose or add a dedicated table)",
        "[ ] Add Gin handlers: POST /auth/user/phone/change/request, POST /auth/user/phone/change/confirm, POST /auth/user/phone/change/resend",
        "[ ] Add rate limit keys for request/confirm/resend",
        "[ ] Update docs (api-endpoints.md) with phone change routes and expected errors"
      ],
      "completed": false
    },
    {
      "name": "Add phone verification request endpoint",
      "id_number": 5,
      "description": "Add POST /auth/phone/verify/request endpoint for existing users to add/verify a phone number, mirroring the existing POST /auth/email/verify/request flow.",
      "tasks": [
        "[DONE] Add RequestPhoneVerificationByPhone() method to core/service.go",
        "[DONE] Create phone_verify_request_post.go handler",
        "[DONE] Add rate limit constant RLPhoneVerifyRequest to ginutil",
        "[DONE] Wire up route in service.go GinRegisterAPI",
        "[DONE] Update api-endpoints.md documentation"
      ],
      "completed": true
    },
    {
      "name": "Enhance UserContext with convenience methods",
      "id_number": 6,
      "description": "Both doujins and hentai0 wrap authkit's UserContext with their own logic to check roles/entitlements. This should be built into authkit's UserContext directly.\n\n## Problem\n\ndoujins has `internal/auth/user_context.go` with:\n```go\ntype UserContext struct {\n    User         *views.User  // Project-specific\n    IsAdmin      bool\n    IsLoggedIn   bool\n    Language     string\n    Roles        []string\n    Entitlements []string\n}\n```\n\nAnd `internal/middleware/user_context.go` computes these flags:\n```go\nuserCtx.IsAdmin = containsIgnoreCase(userCtx.Roles, \"admin\")\n```\n\nhentai0 uses authkit's UserContext directly but lacks these convenience methods.\n\n## Solution\n\nAdd convenience methods to authkit's `UserContext` in `adapters/gin/userctx.go`:\n\n```go\n// Already exists:\nfunc (uc UserContext) IsAdmin() bool { return hasString(uc.Roles, \"admin\") }\n\n// Add these:\nfunc (uc UserContext) IsLoggedIn() bool { return uc.UserID != \"\" }\nfunc (uc UserContext) HasRole(role string) bool { return hasString(uc.Roles, role) }\nfunc (uc UserContext) HasEntitlement(ent string) bool { return hasString(uc.Entitlements, ent) }\n```\n\n## Important: NO IsPremium() method\n\nDo NOT add `IsPremium()` method. This is overly specific and doesn't scale. Instead, callers should use the generic `HasEntitlement(\"premium\")`. Same logic applies to any future entitlement types - use the generic method, not dedicated boolean methods.\n\n## Migration\n\nAfter authkit changes:\n- doujins can simplify `internal/middleware/user_context.go` to just use `authgin.UserContext` methods\n- doujins can potentially remove `internal/auth/user_context.go` if the only additions were computed flags\n- hentai0 gains these methods automatically\n\n## Note\n\nLanguage middleware and response envelopes are NOT part of this issue - those belong in a separate shared library (e.g., `go-api-common`), not authkit.",
      "tasks": [
        "[x] Add IsLoggedIn() method to UserContext (check UserID != \"\")",
        "[x] Add HasRole(role string) method to UserContext",
        "[x] Add HasEntitlement(ent string) method to UserContext",
        "[x] Add unit tests for new UserContext methods",
        "[x] Downstream app wrapper removal tracked in app repos"
      ],
      "completed": true
    },
    {
      "name": "Remove is_active (use ban/delete only)",
      "id_number": 7,
      "description": "Replace the `profiles.users.is_active` boolean with explicit ban/delete semantics.\n\n## Requirements\n\n- Only two access-blocking states exist:\n  - banned (reversible): `banned_at IS NOT NULL`\n  - deleted (soft delete): `deleted_at IS NOT NULL`\n- Admin delete and user self-delete both set `deleted_at` (soft delete) initially.\n- Login/token issuance must refuse banned/deleted users.\n- Deleted users remain soft-deleted for 30 days, then are hard-deleted.\n\n## Target semantics\n\n- Active user is implied: `deleted_at IS NULL AND banned_at IS NULL`.\n- Ban should revoke sessions immediately.\n- Soft delete should revoke sessions immediately.\n- Hard delete occurs after 30 days (purge job).",
      "tasks": [
        "SCHEMA/MIGRATIONS:",
        "[x] Add `profiles.users.banned_at timestamptz` (optional: banned_reason, banned_by)",
        "[x] Backfill `banned_at` for existing users with is_active=false and deleted_at IS NULL (treat as banned)",
        "[x] Remove `profiles.users.is_active` (drop column) after code is migrated",
        "",
        "CORE LOGIC:",
        "[x] Replace all `IsActive` checks with `deleted_at IS NULL AND banned_at IS NULL`",
        "[x] Replace `SetActive` APIs with explicit `BanUser` / `UnbanUser` + `SoftDeleteUser` (deleted_at)",
        "[x] Ensure ban and soft delete revoke refresh sessions (issuer-scoped) consistently",
        "[x] Ensure JWT issuance paths refuse banned/deleted users (password login, OAuth/OIDC callbacks, SIWS, refresh, etc.)",
        "[x] Ensure authz gates respect banned/deleted (Required middleware, RequireAdmin/RequireRole/RequireEntitlement, and any DB-backed UserContext enrichment should deny when banned_at or deleted_at is set)",
        "[x] Ensure admin/live DB checks don’t treat \"row exists\" as sufficient; they must join/filter on `profiles.users` status",
        "",
        "HTTP API:",
        "[x] Change admin ban/unban endpoints to set/clear `banned_at` (and revoke sessions on ban)",
        "[x] Remove or repurpose \"toggle active\" endpoint (make it ban/unban; no generic active toggle)",
        "[x] Change `DELETE /auth/user` to call soft delete (`deleted_at=now()` + revoke sessions)",
        "[x] Change admin delete endpoint to soft delete by default (`deleted_at=now()`), not hard delete",
        "",
        "ADMIN VIEWS:",
        "[x] Update AdminUser / listing to expose `banned_at` and `deleted_at` (and derived booleans if needed)",
        "[x] Update any filters/search that currently use is_active",
        "",
        "RETENTION + PURGE (30 DAYS):",
        "[x] Add `profiles.users.deleted_at` retention policy: hard-delete after 30 days from deleted_at",
        "[x] Provide an AuthKit River module so host apps can \"plug in\" purge without re-implementing logic:",
        "      - A River job args type (`authkit/riverjobs.PurgeDeletedUsersArgs`) with params: retention_days, batch_size",
        "      - A worker implementation that selects `deleted_at < now() - retention_days` and hard-deletes authkit-owned rows",
        "      - Helpers: `RegisterPurgeDeletedUsersWorker` and `AddPurgeDeletedUsersPeriodicJob`",
        "[x] Define a host callback for app-domain cleanup/anonymization, invoked before the authkit hard-delete:",
        "      - `BeforeUserHardDelete(ctx, user_id) error` (delete likes/favorites, anonymize comments, etc.)",
        "[ ] Document and enforce downstream data policy in host apps (examples):",
        "      - comments: keep content by changing FK to `ON DELETE SET NULL` (so author becomes NULL on hard-delete); frontend renders author=NULL as \"user deleted\" (also handle legacy anonymous comments via anon_name when present)",
        "      - reactions/favorites: usually delete (cascade or explicit cleanup)",
        "      - posts/content with non-null author_id: decide per-app (either cascade-delete posts on user hard-delete, or switch author FK to SET NULL and render \"user deleted\")",
        "      - ClickHouse analytics/events: treat as append-only history; user_id may remain in event rows after user purge (acceptable; avoid expensive deletes)",
        "      - billing/audit/security logs: retain required records; remove/obfuscate PII as needed",
        "",
        "TESTS/VALIDATION:",
        "[ ] Add tests: banned users cannot log in; deleted users cannot log in; unban restores access; ban revokes sessions; delete revokes sessions",
        "[ ] Add tests for purge candidate selection: deleted_at older/newer than cutoff",
        "[ ] Run migration path test: old data -> backfill -> code works -> drop is_active"
      ],
      "completed": false
    },
    {
      "name": "Standalone AuthKit dev issuer (Postgres) + mint JWTs for E2E",
      "id_number": 8,
      "description": "Provide a standalone AuthKit **devserver/dummy app** that can be started locally (Docker/compose) using Postgres and can mint JWTs for end-to-end testing of downstream services (e.g. `~/doujins-billing`) as well as AuthKit itself.\n\n## Important constraint\n\nThe dev mint endpoint must live in the **dummy app**, not in the AuthKit library.\n- No changes are required to AuthKit core APIs to support minting.\n- The dummy app just *uses AuthKit as a library* and adds a dev-only route for minting tokens.\n\n## Why\n\nDownstream services that verify JWTs (like billing) need a local issuer that:\n- exposes JWKS at `/.well-known/jwks.json` (already supported by AuthKit gin adapter)\n- can mint short-lived JWTs on demand for API calls\n\nAuthKit already has `testing.TestIssuer` (httptest) for unit tests, but E2E across containers needs a real long-running HTTP service with a stable issuer URL.\n\n## Requirements\n\n- Use Postgres (no sqlite).\n- Safe-by-default: dev minting endpoints must be disabled in production.\n- Usable from docker-compose networks (stable hostname like `issuer:8080`).\n\n## Proposed Design\n\n### 1) Standalone devserver binary\n\nAdd `cmd/authkit-devserver` (or similar) that:\n- connects to Postgres via `DB_URL`/`DATABASE_URL`\n- runs AuthKit migrations (either on boot or via a `migrate` subcommand)\n- starts an HTTP server (gin) that mounts:\n  - AuthKit API routes (`/auth/*`) for normal flows (useful for AuthKit E2E)\n  - JWKS endpoint at `/.well-known/jwks.json` via `authgin.Service.GinRegisterJWKS`\n  - **dev-only** mint endpoint implemented in the devserver (below)\n\n### 2) Dev-only minting API (devserver-owned)\n\nAdd a dev-only endpoint guarded by `AUTHKIT_DEV_MODE=true` and a shared secret `AUTHKIT_DEV_MINT_SECRET`:\n- `POST /auth/dev/mint`\n  - input: `sub`, `aud`, optional `email`, optional `roles`, optional `scopes`, optional `expires_in_seconds`\n  - output: `{token, token_type: \"Bearer\", expires_at}`\n\nSecurity:\n- If `AUTHKIT_DEV_MODE!=true`, this route is not registered.\n- Require `Authorization: Bearer <AUTHKIT_DEV_MINT_SECRET>` (or an `X-DEV-SECRET` header).\n\n### 3) Issuer URL + signing key persistence\n\n- Issuer must be stable across restarts (e.g. `http://issuer:8080` inside compose).\n- Persist signing keys so previously minted tokens remain verifiable after restart.\n  - Option A: store key material in Postgres (recommended)\n  - Option B: store key material in a file mounted as a docker volume\n\n### 4) How this helps billing E2E\n\n- Billing config points to the issuer:\n  - `AUTH_ISSUERS='[\"http://issuer:8080\"]'`\n  - `AUTH_EXPECTED_AUDIENCE=billing-app`\n- Billing E2E scripts call `POST http://issuer:8080/auth/dev/mint`, then use the returned token to call billing APIs.\n\n## Tasks\n\n- [ ] Add `cmd/authkit-devserver` entrypoint (gin server + Postgres)\n- [ ] Add config/env parsing: DB URL, listen addr, dev-mode flags, mint secret\n- [ ] Add migrations execution path (on boot or subcommand)\n- [ ] Implement `/auth/dev/mint` in the devserver (dev-only) + shared-secret guard (no library changes)\n- [ ] Persist signing key material across restarts (DB table or volume-backed file)\n- [ ] Add docker-compose (or documented snippet) to run `postgres` + `authkit-devserver`\n- [ ] Add docs: how to run, how to mint tokens (curl), and example billing integration",
      "tasks": [
        "[x] Implement devserver dummy app (`authkit-devserver.go`, Postgres-backed)",
        "[x] Implement dev-only `/auth/dev/mint` in the devserver (guarded by env + secret)",
        "[x] Persist signing keys across restarts (volume-backed `/.runtime/authkit`)",
        "[x] Add `docker-compose.devserver.yaml` + `DEVSERVER.md` + `Dockerfile.devserver`"
      ],
      "completed": true
    },
    {
      "name": "E2E tests for authkit-devserver (JWKS + mint + core auth flows)",
      "id_number": 9,
      "description": "Add docker-compose-backed E2E tests that exercise AuthKit as a real HTTP server (Postgres-backed), using the new devserver/mint endpoint.\n\n## Why\n\nUnit tests cover helpers and a small set of handlers, but we currently lack end-to-end coverage for:\n- database schema + migrations + boot\n- HTTP routing + middleware + JWT verification via JWKS\n- critical auth flows (password login, refresh, session revocation)\n\nThe devserver gives us a stable issuer and a convenient way to mint tokens for testing protected endpoints without wiring email/SMS providers.\n\n## Current test coverage (today)\n\n- Token verifier/JWKS via `testing.TestIssuer` (httptest): `testing/issuer_test.go`\n- A few Gin adapter tests (handlers + userctx): `adapters/gin/*_test.go`\n- Ephemeral store tests: `core/ephemeral_test.go`\n- SIWS tests: `siws/siws_test.go`\n\n## What we should test (high value)\n\nE2E (docker-compose):\n- Devserver boots, runs migrations, and serves HTTP\n- JWKS served and usable by external verifiers\n- `/auth/dev/mint` guarded correctly and produces valid, expiring JWTs\n- Password login and refresh/session lifecycle against Postgres\n- Banned/deleted users cannot authenticate (and are filtered by DB-backed user lookups)\n- Admin gating is DB-backed (create admin role + grant + confirm admin endpoints work)\n\n## Test structure\n\n- Add E2E tests behind a build tag (e.g. `//go:build e2e`) so they do not run in normal `go test ./...`.\n- The tests shell out to docker compose (`docker compose -f docker-compose.devserver.yaml ...`) with a unique `COMPOSE_PROJECT_NAME`.\n- The tests hit the devserver on `http://localhost:8080` and connect to Postgres on `localhost:5432`.\n\n## Tasks\n\n- [ ] Add `testing/devserver_e2e_test.go` behind `//go:build e2e`\n- [ ] Test: boot + health (`GET /healthz`)\n- [ ] Test: JWKS (`GET /.well-known/jwks.json` returns at least one RSA key)\n- [ ] Test: mint authz\n  - missing/invalid secret => 401\n  - valid secret => 200 + `{token, expires_at}`\n  - `AUTHKIT_DEV_MODE=false` => route not registered (404)\n- [ ] Test: minted token can call an AUTH endpoint when a matching user exists in Postgres\n  - seed `profiles.users` row with same UUID as `sub`\n  - call `GET /auth/user/me` with `Authorization: Bearer <token>` and expect 200\n- [ ] Test: admin gate is DB-backed\n  - seed `profiles.roles` with slug `admin`\n  - seed `profiles.user_roles` mapping for user\n  - call an admin endpoint and expect 200\n- [ ] Test: banned/deleted enforcement\n  - set `profiles.users.banned_at` and verify `GET /auth/user/me` fails (or user is not returned)\n  - set `profiles.users.deleted_at` similarly\n- [ ] Test: password login + refresh\n  - seed `profiles.user_passwords` hash\n  - `POST /auth/password/login` returns access token (and refresh session)\n  - `POST /auth/token` refresh works\n  - revoke session and ensure refresh fails\n- [ ] Docs: add a short section to `DEVSERVER.md` describing how to run E2E tests (`go test -tags=e2e ./testing -run Devserver`)\n",
      "tasks": [
        "[x] Add build-tagged docker-compose E2E test suite",
        "[x] Cover JWKS + /auth/dev/mint (authz + expiry)",
        "[x] Cover core auth flows (login/refresh/sessions)",
        "[x] Cover ban/delete enforcement + admin gate"
      ],
      "completed": true
    },
    {
      "name": "Language-aware AuthKit (propagate request language to senders)",
      "id_number": 11,
      "description": "Make AuthKit language-aware for user-facing communications (email + SMS) by detecting request language and propagating it to the host-provided sender interfaces via `context.Context`.\n\nWhy:\n- Host apps (`~/doujins`, `~/hentai0`) render the email/SMS bodies, but need to know what language-site the user is on at the moment an auth message is sent (signup/login/reset).\n- Some auth flows run before a user profile exists (signup verification), so there is no reliable user_id to look up preferences. Request language is the best signal.\n\nDesign:\n- AuthKit should not depend on host-specific user context types.\n- Introduce an AuthKit-owned context key + helpers to store language in `ctx`.\n- Ensure all calls into EmailSender/SmsSender use the inbound request ctx (or a derived ctx that preserves values), not `context.Background()`.\n\nNotes:\n- This should apply to both API routes and any root/browser flows AuthKit registers.\n- The language source should be configurable but default to: query param `lang` > cookie > `Accept-Language` > default.\n",
      "tasks": [
        "=== SHARED LANGUAGE CONTRACT (ALIGN WITH DOUJINS + HENTAI0) ===",
        "[x] Define and document a single precedence order for request language: `?lang` query param > `/:lang/` path prefix > `lang` cookie > `Accept-Language` header > default",
        "[x] Add AuthKit `LanguageConfig` (supported + default + cookie/query knobs) passed by the host app; validate and reject/ignore unsupported codes",
        "[x] Default behavior when config not provided: accept only basic `^[a-z]{2}$` languages, default to `en`",
        "",
        "[x] Add `lang` context helpers: `WithLanguage(ctx, lang)` and `LanguageFromContext(ctx)`",
        "[x] Add middleware/hook in the Gin adapter to detect language (per the shared contract) and attach it to ctx for every AuthKit request",
        "[x] Ensure AuthKit handlers/services propagate the inbound request ctx through to sender calls (no Background ctx)",
        "[x] Docs: sender implementations can read language from ctx and choose localized templates",
        "[x] Tests: language detection + ctx propagation into a fake sender for email + sms",
        "[x] Tests: ensure `LanguageConfig.Supported` is enforced for query/path/cookie/Accept-Language"
      ],
      "completed": true
    },
    {
      "name": "Decouple request language from UserContext (context key)",
      "id_number": 12,
      "description": "Ensure AuthKit stores request language as request metadata under a dedicated `context.Context` key (AuthKit-owned), not embedded inside any user identity context struct.\n\nWhy:\n- Request language is not user identity.\n- Some flows do not have a user record yet (signup verification), but are still language-scoped.\n- Keeps AuthKit portable: host apps can read language from ctx in senders without coupling to host-specific `UserContext` layouts.\n\nNon-goals:\n- Making language selection configurable per-app (beyond supported/default validation).\n- Translating AuthKit error messages (this issue is about propagation to senders).\n\nRelationship to issue #11:\n- Issue #11 adds language detection + propagation to senders.\n- This issue enforces the storage pattern: language lives at a dedicated context key (not nested under user ctx).",
      "tasks": [
        "[x] Add an AuthKit-owned context key for request language (can reuse the `lang` helpers from issue #11)",
        "[x] Ensure all sender invocations rely on `lang.LanguageFromContext(ctx)` (not user ctx structs) for language selection",
        "[x] Document the pattern for host apps: sender implementations should read request language from ctx and fall back to defaults",
        "[x] Add tests that assert language is present on ctx in both authenticated and unauthenticated auth flows"
      ],
      "completed": true
    },
    {
      "name": "Auth analytics: log session lifecycle (not access-token mints)",
      "id_number": 13,
      "description": "Stop logging every access-token mint as an analytics/audit event. Instead, log session lifecycle + security-relevant transitions:\n\n- Session created (login / refresh session issuance) → useful for audit, device tracking, “new login” alerts.\n- Session revoked/deleted (logout, admin revoke, password change, “revoke all”, eviction by session limit) → critical for audit.\n\nNon-goals:\n- Per-access-token issuance telemetry.\n\nNotes:\n- Keep logging best-effort and non-blocking.\n- Ensure events are disambiguated across host apps (e.g., include `issuer` and/or `site` in the ClickHouse schema/sink if needed).",
      "tasks": [
        "[x] Remove/avoid logging access-token mints (e.g., refresh-exchange events) as primary analytics signals",
        "[x] Add explicit session lifecycle events to the auth logger interface (created, revoked/deleted, revoke-all, eviction)",
        "[x] Emit session-created events from all login/session issuance paths",
        "[x] Emit session-revoked/deleted events from logout + admin revoke + password change + revoke-all + eviction paths",
        "[x] Remove Postgres `profiles.signin_history` (stop writing to it, migrate/drop table, and update admin sign-in history endpoints to use ClickHouse if still needed)",
        "[x] Replace ClickHouse auth tables with a single `user_auth_session_events` table (session lifecycle only, not access-token mints)",
        "[x] ClickHouse schema: include `issuer`, `session_id` (`sid`), `event`, `method`, optional `reason`, plus `ip_addr`/`user_agent`",
        "[x] Update ClickHouse sink to persist `issuer` + `session_id` + event fields (host app implementation; include `site` only if issuer is insufficient)",
        "[x] Add a new ClickHouse migration that drops old auth tables/views and creates `user_auth_session_events` (no legacy compatibility, no data backfill)",
        "[x] Drop `user_last_seen_current` and related materialized views; rely on queries over `user_auth_session_events` instead"
      ],
      "completed": true
    },
    {
      "name": "Plan: framework-agnostic selective billing http.Handler",
      "id_number": 14,
      "description": "Track work needed to expose doujins-billing HTTP routes as a single mountable `http.Handler` *with selective route groups* (user/admin/webhooks/health), while staying framework-agnostic for hosts.\n\n## Context\n\ncozy-art currently embeds doujins-billing and mounts it under `/billing`. Some host routers (notably Gin) have route-tree constraints around catch-all wildcards, so the integration surface should be a single handler mounted via `http.StripPrefix`/outer mux.\n\nWe also want optionality: some hosts should be able to mount only webhooks, only admin, etc., without exposing the full billing HTTP surface.\n\n## Goal\n\nIn doujins-billing, add a public handler builder such as:\n\n```go\ntype HTTPHandlerOptions struct {\n  IncludeUser bool\n  IncludeAdmin bool\n  IncludeWebhooks bool\n  IncludeHealth bool\n  // optionally: IncludeDebug (dev only)\n}\n\nfunc (e *embedded.Embedded) NewHTTPHandler(opts HTTPHandlerOptions) http.Handler\n```\n\nDefaults should preserve existing standalone behavior, while giving embedded hosts fine-grained control.\n\n## Non-goals\n\n- Do not put billing route selection into authkit; authkit should remain focused on auth routes.\n- Do not reintroduce Gin-only embedding APIs as the primary integration surface.\n\nStatus update (2026-01-27): implemented in doujins-billing + wired into cozy-art.",
      "tasks": [
        "doujins-billing implementation:",
        "[x] Define exported options type (include flags) and document semantics",
        "[x] Build a single handler that registers only selected route groups",
        "[x] Keep `Handler()` as backwards-compatible shorthand (all groups)",
        "[x] Ensure admin routes still enforce auth/admin checks internally",
        "[x] Add tests that assert excluded groups return 404 (and included groups are not 404)",
        "[x] Update embedded README with mounting examples",
        "\ncozy-art integration:",
        "[x] Mount billing using the selective handler options",
        "[x] Verify no Gin wildcard route panics",
        "\nMigration/cleanup:",
        "[ ] Tag/release doujins-billing once satisfied"
      ],
      "completed": true
    },
    {
      "name": "Security audit events: password reset requests (non-session)",
      "id_number": 15,
      "description": "Add a separate, non-session security audit event stream for flows like password reset requests.\n\nWhy:\n- Password reset requests are security-relevant, but are not session lifecycle events and should not be mixed into `user_auth_session_events`.\n- Host apps may want an audit trail for account recovery activity without logging per-access-token issuance.\n\nDesign:\n- Add a new ClickHouse table (e.g., `user_auth_security_events`) keyed by `(issuer, occurred_at, event, user_id?)`.\n- Add a dedicated logger interface/method (separate from session events) so session lifecycle logging remains focused.\n- Avoid logging raw identifiers (email/phone). Prefer `user_id` when known; otherwise log a hash + identifier type if absolutely needed.\n\nEvents (initial):\n- `password_reset_requested` (email/phone)\n\nNon-goals:\n- Changing session lifecycle logging.\n- Per-access-token mint telemetry.",
      "tasks": [
        "[ ] Define `SecurityEvent` types and a new logger interface (separate from session events)",
        "[ ] Add ClickHouse migration to create `user_auth_security_events`",
        "[ ] Emit `password_reset_requested` events from the password reset request handlers (email + phone) with issuer + ip/ua, and user_id only when resolvable",
        "[ ] Decide on identifier logging policy (no raw email/phone; optional hash if needed) and document it",
        "[ ] Update host apps' ClickHouse sink(s) to insert into `user_auth_security_events`"
      ],
      "completed": false
    },
    {
      "name": "Framework-agnostic net/http adapter (adapters/http)",
      "id_number": 16,
      "description": "Add a first-class `net/http` transport for AuthKit so host apps can embed AuthKit without Gin.\n\n## Motivation\n\nToday AuthKit’s HTTP surface is implemented via the Gin adapter (`adapters/gin`). That works well for Gin apps, but it couples embedding to Gin’s router/middleware model. A native `net/http` adapter makes embedding framework-agnostic (stdlib mux, chi, echo via bridge, Lambda/APIGW, etc.) and reduces dependency friction for non-Gin hosts.\n\n## High-level approach (staged migration)\n\n1) Introduce `adapters/http` that implements the same routes using `net/http` handlers and std context.\n2) Keep `adapters/gin` supported initially. Optionally, later make Gin adapter a thin shim that delegates to the `net/http` adapter (Gin → ServeHTTP), once parity is proven.\n3) Migrate tests to validate the `net/http` adapter, and add parity tests to prevent behavior drift.\n\n## Scope\n\n- Provide handler registration/mounting for:\n  - JWKS: `GET /.well-known/jwks.json`\n  - Browser flows: `/auth/oidc/:provider/login`, `/auth/oidc/:provider/callback`, and discord oauth routes if configured\n  - JSON API: `/auth/*` endpoints (password login, register, sessions, user, admin, SIWS, etc.)\n- Preserve existing response shapes and status codes where feasible.\n\n## Non-goals\n\n- Do not change core business logic (`core/*`) beyond small helpers needed for transport neutrality.\n- Do not remove Gin adapter in the first iteration.\n- No API redesign; focus on transport parity.\n\n## Risks\n\n- Behavior drift (status codes, error payloads, headers) unless parity-tested.\n- Replacing Gin binding/validation and middleware chaining requires careful design.",
      "tasks": [
        "Design:",
        "[x] Decide adapter public API: `authhttp.NewService(core.Config)` plus mountable handler methods (`JWKSHandler`, `APIHandler`, `OIDCHandler`)",
        "[x] Decide mounting strategy: expose multiple mountable handlers (JWKS/API/OIDC) rather than a single all-in-one handler",
        "[x] Define shared error envelope + helpers for consistent responses",
        "\nImplementation (adapters/http):",
        "[x] Add `adapters/http` package skeleton",
        "[x] Implement JWKS handler (parity with gin handler)",
        "[x] Implement auth middleware for Required/Optional using core verifier",
        "[x] Implement request parsing + validation (stdlib + validator library or minimal custom)",
        "[x] Implement JSON API endpoints (route-by-route parity)",
        "[x] Implement OIDC/OAuth browser flows endpoints",
        "[x] Implement SIWS endpoints",
        "[x] Implement admin routes (RequireAdmin DB check)",
        "\nTesting:",
        "[x] Add route-parity tests (Gin vs net/http) for critical endpoints",
        "[x] Add httptest coverage for net/http adapter",
        "[x] Add golden tests for error shapes/status codes for high-traffic endpoints",
        "\nMigration:",
        "[x] Add docs showing embedding in stdlib mux + example Gin mount via `gin.WrapH`",
        "[ ] (Optional) refactor gin adapter to call net/http adapter where practical"
      ],
      "completed": true
    },
    {
      "name": "Drop Gin adapter + ginutil (breaking): rely fully on net/http routing",
      "id_number": 17,
      "description": "AuthKit now has a full `net/http` adapter (`adapters/http`, package `authhttp`). We want to remove all Gin-specific logic and dependencies from this repo and rely exclusively on the new router/handler implementation.\n\nThis is a deliberate breaking change: downstream projects that import `github.com/open-rails/authkit/adapters/gin` or `adapters/ginutil` will need to migrate to `adapters/http`.\n\nNon-goals:\n- Backwards compatibility for Gin hosts.\n- Shim layers that keep Gin working.\n\nSuccess criteria:\n- No Gin dependency in AuthKit.\n- `go test ./...` passes.\n- README/docs show only `authhttp` mounting.",
      "tasks": [
        "[x] Inventory all Gin usages in-repo (packages, tests, docs) and decide the deletion scope (`adapters/gin`, `adapters/ginutil`, any local helpers).",
        "[x] Remove Gin-specific packages (`adapters/gin`, `adapters/ginutil`) and any Gin-only helpers that are no longer used.",
        "[x] Update/replace tests that import Gin (e.g. route-parity tests) so the suite does not depend on Gin at all.",
        "[x] Update README/docs/examples to show only `authhttp` usage; remove `authgin.*` references.",
        "[x] Remove Gin-related module deps from `go.mod`/`go.sum` (`github.com/gin-gonic/gin`, etc.) and run `go mod tidy`.",
        "[x] Verify: `go test ./...` passes.",
        "[x] Versioning: decide and apply a breaking-release strategy (e.g. bump major tag) for downstream migration clarity."
      ],
      "completed": true
    },
    {
      "name": "Rate limiting: sensible secure defaults (on by default)",
      "id_number": 18,
      "description": "AuthKit’s `authhttp` adapter has per-endpoint rate limit buckets, but rate limiting is currently effectively disabled unless a host app calls `svc.WithRateLimiter(...)`.\n\nThat is a security footgun (password login / token exchange / reset / OIDC start/callback are unthrottled by default).\n\nGoal:\n- Provide sensible, secure default rate limiting behavior out-of-the-box.\n\nNon-goals:\n- Perfect bot protection.\n- Persisting/migrating legacy limiter state.\n\nKey requirements:\n- Defaults must be safe in prod and not accidentally rate-limit a reverse proxy (need configurable client IP extraction / trusted proxy model).\n- Hosts must be able to override limits and to explicitly disable rate limiting (opt-out).\n- Behavior must fail-open on limiter backend errors (availability > throttle correctness).",
      "tasks": [
        "[x] Decide default limiter behavior: enable memorylimiter by default vs require explicit config in prod (and how to detect prod).",
        "[x] Define the default per-bucket limits (reuse existing bucket names: `RLPasswordLogin`, `RLAuthToken`, `RLOIDCStart`, etc.).",
        "[x] Add a first-class client IP strategy to `authhttp`:\n  - default: RemoteAddr\n  - optional: trusted proxy list / header-based extraction (X-Forwarded-For, CF-Connecting-IP) to avoid limiting the proxy itself.",
        "[x] Implement: when no limiter is configured, install the default limiter (and defaults) automatically; add an explicit opt-out (e.g. `DisableRateLimiter()` or `WithRateLimiter(NoopLimiter)`).",
        "[x] Docs: update README / adapter docs with guidance for multi-instance prod (Redis limiter) + proxy configuration.",
        "[x] Tests: add minimal coverage that rate limiting is active by default (and that opt-out disables it).",
        "[x] Verify: `go test ./...` passes."
      ],
      "completed": true
    },
    {
      "name": "JWT verification: require `exp` for access tokens (verify-only AcceptConfig too)",
      "id_number": 19,
      "description": "Today `authhttp.Required(...)` always parses tokens with `jwt.ParseWithClaims` (which validates registered time claims if present), but in verify-only mode (multi-issuer `AcceptConfig`) our explicit expiry check is only applied when `exp` exists.\n\nThat means a signed token that omits `exp` could be accepted in verify-only mode as long as signature + issuer/audience match.\n\nGoal:\n- Require `exp` to be present on access tokens in all verification modes (service-issued and verify-only).\n\nNon-goals:\n- Requiring `nbf` or `iat` to exist.\n\nRequirements:\n- Continue to validate `nbf`/`iat` when present (via jwt library validation and/or explicit checks).\n- Apply a small skew allowance (existing behavior).\n- Produce stable error codes (e.g. `missing_exp`, `token_expired`).",
      "tasks": [
        "[x] Decide enforcement: require `exp` for access tokens (no opt-out).",
        "[x] Update `authhttp.Required` to reject tokens missing `exp` in both service-issued and verify-only (`AcceptConfig`) modes.",
        "[x] Ensure `nbf`/`iat` are still validated when present (but not required).",
        "[x] Add tests covering: missing `exp` rejected; expired rejected; valid with `nbf` in future rejected; valid without `nbf`/`iat` accepted.",
        "[x] Verify: `go test ./...` passes."
      ],
      "completed": true
    },
    {
      "name": "Organizations (tenants) + RBAC in AuthKit",
      "id_number": 20,
      "description": "Add first-class organizations to AuthKit so users can belong to multiple orgs and services can rely on a consistent org/tenant model across the platform.\n\nGoal:\n- AuthKit is the source of truth for: orgs, memberships, and org-assigned role strings.\n- Roles are opaque strings (org-defined). AuthKit stores them; each application decides what roles mean (permission mapping) within that org.\n\nDesign notes:\n- Host configuration selects org behavior via `org_mode`: `single` (default) or `multi`.\n- Default behavior is `org_mode: single` when no org config is provided.\n\n- `org_mode: single`:\n  - JWTs include `roles` (string[]); no org claim.\n  - `GET /auth/user/me` returns roles only.\n\n- `org_mode: multi`:\n  - Users may belong to 0 orgs, 1 org, or multiple orgs simultaneously.\n  - Default access tokens do NOT embed org membership or org roles; host apps do server-side membership/role checks (GitHub-style).\n  - `GET /auth/user/me` returns all org memberships + all org-scoped roles (server-side).\n  - Optional org-scoped token minting: `POST /auth/token/org` can mint a JWT containing `org` + `roles` for a single org.\n  - Never allow minting org/role claims the user does not have.\n\n- Org identifiers are slugs (human-readable). Slug renames create aliases; aliases must remain valid for auth.\n- Support deployments moving from `single` -> `multi` via configuration.\n- Mode transitions:\n  - `single` -> `multi` must be allowed by configuration change at any time.\n  - `multi` -> `single` should be rejected as a safeguard when there is more than one organization with more than one member (1 org with many members is allowed to downgrade).\n\n- Guardrails are required (hardcoded sensible defaults; not configurable):\n  - Limit org slug/alias length and character set.\n  - Limit role length and character set.\n  - Limit max org memberships per user.\n  - Limit max roles per org membership.\n\n- Claim contract:\n  - Single mode tokens: roles (string[])\n  - Multi mode default tokens: no org/roles claims\n  - Multi mode org-scoped tokens (via `POST /auth/token/org`): org (string) + roles (string[])\n\nNon-goals (v1):\n- Fine-grained per-resource ACLs (repo-level ACLs, etc.).\n- Billing/quota enforcement.\n- Full invitation UX (email invites), beyond basic admin APIs.",
      "tasks": [
        "[x] Data model + migrations\n    - orgs table: id (uuid), slug (unique current slug), created_at, updated_at, deleted_at\n    - org_slug_aliases table: org_id, slug (unique alias), created_at, deleted_at (optional)\n      - On rename: insert old slug into org_slug_aliases, update orgs.slug to new slug\n      - Aliases should remain valid for auth forever (or very long) to avoid breaking tokens\n    - org_members table: org_id, user_id, created_at, updated_at, deleted_at; unique(org_id,user_id)\n    - org_roles table: org_id, role (text), created_at; unique(org_id, role)\n    - org_member_roles table: org_id, user_id, role; unique(org_id,user_id,role)\n    - Constraints/validation (guardrails):\n      - org slug/alias length + character set\n      - role length + character set\n    - Indexes for slug/alias lookup and membership checks",
        "[x] Core service API\n    - CreateOrg(slug) (admin-only or self-serve with rate limit)\n    - RenameOrgSlug(org_id, new_slug) (create alias for old slug)\n    - ResolveOrgBySlug(slug) -> org (accepts current slug or alias; aliases are implicit)\n    - ListOrgMembershipsForUser(user_id) -> []{org}\n    - AddMember(org_id, user_id), RemoveMember(org_id, user_id) (org owner via HTTP)\n    - DefineRole(org_id, role), DeleteRole(org_id, role) (org owner via HTTP; `owner` is protected)\n    - AssignRole(org_id, user_id, role), UnassignRole(org_id, user_id, role) (org owner via HTTP; cannot remove last owner)\n    - ReadMemberRoles(org_id, user_id)\n    - Enforce guardrails (max org memberships per user; max roles per membership; slug/role validation on writes)",
        "[x] HTTP API endpoints\n    - GET /auth/orgs (list orgs for current user)\n    - POST /auth/orgs (create org)\n    - GET /auth/orgs/:org (metadata; :org accepts slug or alias)\n    - POST /auth/orgs/:org/rename (rename slug; keep alias)\n    - GET/POST/DELETE /auth/orgs/:org/members\n    - GET/POST/DELETE /auth/orgs/:org/roles and /auth/orgs/:org/members/:user_id/roles\n    - POST /auth/token/org (mint org-scoped access token: `org` + `roles`)\n    - GET /auth/user/me (multi: includes org memberships + org-scoped roles; single: roles only)",
        "[x] AuthZ rules\n    - Only org `owner` can manage members + role definitions + role assignments\n    - Normal members can list org metadata they belong to\n    - Owner bootstrap behavior on org create",
        "[x] Token claims + optional org-scoped minting\n    - `org_mode: single`: include `roles` (string[]) in JWT (no org claim)\n    - `org_mode: multi` default: JWT has no org/roles claims; host apps check membership/roles server-side\n    - `POST /auth/token/org`: accept `org` parameter; if user is a member, include:\n      - org (string)\n      - roles (string[]) for that org\n    - Reject org-scoped minting when user is not a member of the org\n    - Support aliases via ResolveOrgBySlug (slug or alias accepted); mint canonical slug\n    - Provide an `authhttp` helper for consistent server-side org membership/role checks\n    - `org_mode` behavior:\n      - Default is `single` when unset\n      - `single` -> `multi` supported via config change\n      - `multi` -> `single` rejected when >1 org has >1 member\n    - No scopes claim in v1",
        "[x] Tests\n    - Core: validate org slug/role guardrails\n    - Token mint (single): `roles` claim present\n    - Token mint (multi default): no org/roles claims present\n    - Token mint (multi org-scoped via /auth/token/org): includes `org` + `roles`\n    - HTTP routing: org endpoints are only exposed in org_mode=multi\n    - Verify: `go test ./...` passes",
        "[x] Docs\n    - Update README/API docs for org endpoints and claim semantics\n    - Document slug renames + alias semantics (tokens/keys are not broken)"
      ],
      "completed": true
    },
    {
      "name": "Org-scoped token ergonomics + claim alignment (post-v1)",
      "id_number": 21,
      "description": "Refinements based on common industry patterns (Auth0/Entra/Keycloak/WorkOS/etc.) to make AuthKit's org-mode integration more ergonomic and more consistent in claim naming across token types.\n\nGoals:\n- Reduce client round trips by allowing org selection at login/refresh.\n- Use consistent claim names across single vs org-scoped tokens.\n\nNon-goals:\n- Changing the v1 org data model.\n- Embedding full org memberships in default tokens (multi mode stays server-side by design).",
      "tasks": [
        "[x] Claim naming alignment\n    - For org-scoped tokens minted in `org_mode: multi`, use `org` (string) + `roles` (string[])\n    - No `org_roles` claim",
        "[x] Login/refresh ergonomics\n    - Allow `POST /auth/password/login` to accept optional `org` in request (multi mode only)\n      - When provided and user is a member: mint org-scoped access token (`org` + `roles`)\n      - When omitted: mint default access token (no org claims)\n    - Allow refresh/token exchange endpoint(s) to accept optional `org` similarly\n    - Keep `POST /auth/token/org` as an explicit minting endpoint (still useful for org switching without re-auth)",
        "[x] Doc updates\n    - Update README and `agents/api-endpoints.md` to describe optional `org` parameter and claim name changes\n    - Document a recommended client-side org switching flow (me -> select org -> token/org or refresh-with-org)",
        "[x] Tests\n    - Validate claim parsing treats `roles` as org-scoped roles when `org` is present\n    - Validate login/refresh optional `org` behavior in multi mode",
        "[ ] (Deferred) Scopes\n    - Out of scope for now; revisit later if a gateway integration requires it"
      ],
      "completed": false
    }
  ],
  "completed_features": [
    {
      "name": "Sign In With Solana (SIWS)",
      "completed_at": "2025-12-04",
      "summary": "Implemented SIWS authentication with challenge/login/link endpoints, Ed25519 signature verification, and nonce-based replay protection."
    }
  ]
}
