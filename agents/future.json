{
  "issues": [
    {
      "name": "Magic links for verification + password reset (standard policy; excludes magic-login)",
      "id_number": 10,
      "description": "Implemented standard policy (not configurable in AuthKit):\n- Email:\n  - verification: code + link (apps can embed the code in a URL)\n  - password reset: link-only (high-entropy token; no reset codes)\n- SMS:\n  - verification: code-only (Twilio Verify)\n  - password reset: link-only (Twilio Messaging/SMS API; not Verify)\n\nAuthKit notes:\n- AuthKit does not know site base URLs or frontend routes. Host apps construct user-facing links in their templates.\n- Password reset tokens are high entropy, single-use, short TTL, stored server-side as hashes (ephemeral store).\n- Added confirm-link endpoints that accept a `token` field, plus backward-compatible behavior where legacy `code` fields carry the token.\n\nOut of scope: magic-link login (passwordless login links). Track separately.",
      "tasks": [
        "[x] Switch password reset to link-only tokens (randB64(32) + hashed storage; no 6-digit reset codes)",
        "[x] Add `core.EmailSenderWithPasswordResetLink` and require it for email password reset delivery",
        "[x] Add `core.SMSSenderWithPasswordResetLink` and use it for SMS password reset delivery (Twilio Messaging/SMS API)",
        "[x] Keep verification codes for email/SMS verification (Twilio Verify for SMS); apps can include a URL that embeds the verification code",
        "[x] Update existing reset confirm handlers to treat the value as a case-sensitive token (no uppercasing; no 6-char assumptions)",
        "[x] Add POST `/auth/password/reset/confirm-link` (expects `token`) and POST `/auth/email/verify/confirm-link` (expects `token`)",
        "[x] Update `agents/api-endpoints.md` to document confirm-link endpoints and token-based reset confirm",
        "[x] Run `go test ./...`"
      ],
      "completed": true
    },
    {
      "name": "Magic-link login (passwordless) via email/SMS (separate from verify/reset)",
      "id_number": 13,
      "description": "Add optional passwordless login using one-time magic links. This is intentionally separate from verification/password reset links.\n\nGoals:\n- Allow a user to request a login link to email (and optionally SMS) and authenticate by clicking it.\n- Keep existing password + 2FA flows intact; magic login is additive and can be disabled entirely.\n\nSecurity notes:\n- High-entropy, single-use, short TTL tokens stored as hashes.\n- Prevent open redirects; fixed redirect or allowlist.\n- Rate limit requests and token consumption; do not leak whether a user exists.\n- Consider session fixation and device binding (optional).\n\nUX:\n- Link lands on host frontend route (e.g. `/auth/magic?token=...`) which calls AuthKit to consume token and then stores session tokens.\n\nProvider notes:\n- Email is straightforward.\n- SMS magic links require Twilio Messaging/SMS API (not Twilio Verify).",
      "tasks": [
        "[ ] Add request endpoint(s): POST /auth/magic-link/request (email/phone) with anti-enumeration response",
        "[ ] Add consume endpoint(s): POST /auth/magic-link/confirm {token} -> mint session (access/refresh) and consume token",
        "[ ] Add ephemeral store keys + TTL + single-use enforcement",
        "[ ] Add rate limits for request + confirm",
        "[ ] Add optional sender interfaces for magic-login links (email + SMS messaging)",
        "[ ] Add tests (token lifecycle, request anti-enumeration, confirm success/expired)",
        "[ ] Docs: flows, security guidance, host frontend route expectations"
      ],
      "completed": false
    },
    {
      "name": "AuthKit as a standalone service (first-class deployment target)",
      "id_number": 14,
      "description": "Today AuthKit is primarily used as a library embedded in host services (doujins/hentai0/openrails) and via a devserver used for E2E testing.\n\nDefine and implement a supported mode where AuthKit runs as its own standalone HTTP service that:\n- mints and verifies JWTs for multiple downstream services\n- serves JWKS at a stable URL\n- provides the full AuthKit API surface under `/auth/*`\n- can be deployed independently (Docker/Kubernetes) with clear configuration and operational guidance.\n\nGoals:\n- Stable, documented deployment contract (env/config) for AuthKit-as-a-service.\n- Downstream services can integrate by trusting issuers (JWKS fetch) + expected audiences.\n- Support multi-instance deployments safely (durable store + Redis for ephemeral/rate-limit where required).\n\nNon-goals:\n- Forcing downstream services to stop embedding AuthKit (embedding remains valid).\n- Becoming a full OAuth authorization server with third-party client registration UX (keep AuthKit's scope).\n\nKey design questions to answer:\n- Issuer and audience strategy (single issuer vs per-service issuers; how to partition).\n- Key management (rotation, persistence, JWKS caching headers).\n- Storage requirements (Postgres always; Redis optional vs required for HA).\n- Service-to-service auth and admin API exposure.",
      "tasks": [
        "[ ] Define the standalone service contract\n    - Public base URL + issuer URL (`AUTHKIT_ISSUER`)\n    - Audience model (per downstream service vs shared audiences)\n    - Required configuration for prod vs dev (DB_URL, Redis, proxy/trust headers, CORS, etc.)",
        "[ ] Create a production-grade server entrypoint\n    - Dedicated `cmd/authkit-server` (or similar)\n    - Health endpoints (ready/live)\n    - Structured logging + request IDs\n    - Graceful shutdown",
        "[ ] Key management & JWKS\n    - Decide persistence strategy for signing keys (Postgres vs filesystem vs KMS)\n    - Key rotation policy + backward-compatible JWKS publication\n    - Cache headers on `/.well-known/jwks.json`",
        "[ ] Storage & HA posture\n    - Postgres required for durable state\n    - Decide when Redis is required (multi-instance) for ephemeral state and rate limiting\n    - Document store modes and safe defaults",
        "[ ] Service-to-service integration guidance\n    - Document how downstream services should verify tokens (issuer list, aud, jwks url)\n    - Provide example configs for OpenRails/Doujins\n    - Add a minimal example client/verifier snippet",
        "[ ] Docker/Kubernetes packaging\n    - A dedicated Dockerfile for the standalone server image\n    - Example `docker-compose.yaml` (Postgres + Redis + AuthKit)\n    - K8s manifests/Helm hints (optional)",
        "[ ] Security hardening\n    - Ensure no dev-only endpoints ship enabled by default\n    - Trusted proxy configuration for IP extraction (X-Forwarded-For/CF-Connecting-IP)\n    - Default rate limits on sensitive endpoints",
        "[ ] Documentation\n    - Update README with \"Standalone deployment\" section\n    - Add operational runbook (migrations, backups, key rotation, incident notes)\n    - Add an explicit compatibility note for embedded usage"
      ],
      "completed": false
    }
  ]
}
